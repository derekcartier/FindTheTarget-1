{"version":3,"sources":["decompose.js","possibleResults.js","hiddenNumber.js","test.js","index.js"],"names":["concat","element","array","length","map","e","decompose","number","decompositions","substr","rawDecomposition","i","str","replace","possibleResults","decomposition","results","indexesUsedForResult","operations","j","add","push","sub","Math","abs","len","max","min","recontructHost","usedIndexes","newHost","doesItStartWith","potentialStart","target","answer","newTarget","usedFirst","hiddenNumber","host","usedLast","reset","d","r","filter","indexes","usesFirst","indexOf","splice","usedLastHere","success","steps","forEach","result","console","log","ReactDOM","render","useState","state","setState","onChange","name","value","type","autoFocus","className","step","index","key","document","getElementById"],"mappings":"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","file":"static/js/main.91b8ca98.chunk.js","sourcesContent":["// precondition : array has 2 dimensions\n// concat adds element in the beginning of each array component\nfunction concat(element, array) {\n  if (array.length === 0) {\n    return [[element]];\n  }\n\n  return array.map(e => [element, ...e]);\n}\n\nfunction rawDecomposition(number) {\n  if (number.length === 0) {\n    return [];\n  }\n\n  if (number.length === 1) {\n    //  console.log(\"case 1 : \", [[number]]);\n    return [[number]];\n  }\n\n  if (number.length === 2) {\n    //console.log(\"case 2 : \", [[number[0], number[1]], [number]]);\n    return [[number[0], number[1]], [number]];\n  }\n\n  if (number.length === 3) {\n    return [\n      [number.substr(0, 1), number.substr(1, 1), number.substr(2, 1)],\n      [number.substr(0, 1), number.substr(1, 2)],\n      [number.substr(0, 2), number.substr(2, 1)],\n      [number]\n    ];\n  }\n\n  return [\n    ...concat(number.substr(0, 1), decompose(number.substr(1))),\n    ...concat(number.substr(0, 2), decompose(number.substr(2))),\n    ...concat(number.substr(0, 3), decompose(number.substr(3))),\n    ...concat(number.substr(0, 4), decompose(number.substr(4)))\n  ];\n}\n\nexport default function decompose(number) {\n  const decompositions = rawDecomposition(number);\n  for (let i in decompositions) {\n    decompositions[i] = decompositions[i].map(str =>\n      str.replace(/0+(.+)/, \"$1\")\n    );\n  }\n  return decompositions;\n}\n","export default function possibleResults(decomposition) {\n  const results = [];\n  const indexesUsedForResult = [];\n  const operations = [];\n\n  // This loop computes all possible combinations between two elements of decomposition\n  for (let i = 0; i < decomposition.length - 1; i++) {\n    const j = i + 1;\n    const add = 1 * decomposition[i] + 1 * decomposition[j];\n    results.push(`${add}`);\n    indexesUsedForResult.push([i, j]);\n    operations.push(`(${decomposition[i]} + ${decomposition[j]} = ${add})`);\n\n    const sub = Math.abs(1 * decomposition[i] - 1 * decomposition[j]);\n    results.push(`${sub}`);\n    indexesUsedForResult.push([i, j]);\n    operations.push(`(${decomposition[i]} - ${decomposition[j]} = ${sub})`);\n  }\n\n  // At this point results only contain combinations of two elements of decomposition\n  const len = results.length;\n\n  //This loop computes all possible results between a combination and an element of decomposition\n  for (let i = 0; i < len - 1; i++) {\n    const j = Math.max(...indexesUsedForResult[i]) + 1;\n    const add = 1 * results[i] + 1 * decomposition[j];\n    results.push(`${add}`);\n    indexesUsedForResult.push([...indexesUsedForResult[i], j]);\n    operations.push(\n      `${operations[i]} (${results[i]} + ${decomposition[j]} = ${add})`\n    );\n\n    const sub = Math.abs(1 * results[i] - 1 * decomposition[j]);\n    results.push(`${sub}`);\n    indexesUsedForResult.push([...indexesUsedForResult[i], j]);\n    operations.push(\n      `${operations[i]} (${results[i]} - ${decomposition[j]} = ${sub})`\n    );\n  }\n\n  // This loop computes all possible results that are combinations between two combinations\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (\n        Math.max(...indexesUsedForResult[i]) + 1 ===\n        Math.min(...indexesUsedForResult[j])\n      ) {\n        const add = 1 * results[i] + 1 * results[j];\n        results.push(`${add}`);\n        indexesUsedForResult.push([\n          ...indexesUsedForResult[i],\n          ...indexesUsedForResult[j]\n        ]);\n        operations.push(\n          `${operations[i]} ${operations[j]} (${results[i]} + ${results[j]} = ${add})`\n        );\n\n        const sub = Math.abs(1 * results[i] - 1 * results[j]);\n        results.push(`${sub}`);\n        indexesUsedForResult.push([\n          ...indexesUsedForResult[i],\n          ...indexesUsedForResult[j]\n        ]);\n        operations.push(\n          `${operations[i]} ${operations[j]} (${results[i]} - ${results[j]} = ${sub})`\n        );\n      }\n    }\n  }\n\n  return { results, indexesUsedForResult, operations };\n}\n","import decompose from \"./decompose\";\nimport possibleResults from \"./possibleResults\";\n\n// starts from a decomposition of a host and used indexes from the previous step\n// and recontructs the new host to work with\nfunction recontructHost(decomposition, usedIndexes) {\n  let newHost = \"\";\n  for (let i of usedIndexes) {\n    newHost += decomposition[i];\n  }\n  for (\n    let i = usedIndexes[usedIndexes.length - 1] + 1;\n    i < decomposition.length;\n    i++\n  ) {\n    newHost += decomposition[i];\n  }\n  return newHost;\n}\n\n// doesItStartWith verifies if target starts with potentialStart\n// In which case, answer is true and newTarget is the remaining part of target\n// Otherwise, answer is false and newTarget is empty\nexport function doesItStartWith(potentialStart, target) {\n  let answer = target.substr(0, potentialStart.length) === potentialStart;\n  let newTarget = \"\";\n  if (answer) {\n    newTarget = target.substr(potentialStart.length);\n  }\n  return { answer, newTarget };\n}\n\nlet usedFirst = false;\n\nexport default function hiddenNumber(target, host, usedLast, reset = false) {\n  if (reset) {\n    usedFirst = false;\n    usedLast = false;\n  }\n\n  let decompositions = decompose(host);\n\n  for (let d of decompositions) {\n    let { results, indexesUsedForResult, operations } = possibleResults(d);\n    if (!usedFirst) {\n      indexesUsedForResult.filter((indexes, i) => {\n        const usesFirst = indexes.indexOf(0) >= 0;\n        if (!usesFirst) {\n          results.splice(i);\n        }\n        return usesFirst;\n      });\n    }\n    usedFirst = true;\n\n    for (let r in results) {\n      let usedLastHere = usedLast;\n      let { answer, newTarget } = doesItStartWith(results[r], target);\n      if (answer) {\n        if (!usedLastHere && newTarget === \"\") {\n          usedLastHere =\n            indexesUsedForResult[r][indexesUsedForResult[r].length - 1] ===\n            d.length - 1;\n          // console.log({ usedLast, d, indexes: indexesUsedForResult[r] });\n          // console.log({\n          //   host,\n          //   step: operations[r],\n          //   potentialStart: results[r],\n          //   target,\n          //   newTarget,\n          //   indexes: indexesUsedForResult[r]\n          // });\n        }\n\n        if (newTarget === \"\" && usedLastHere) {\n          return { success: true, steps: [operations[r]] };\n        }\n        let newHost = recontructHost(d, indexesUsedForResult[r]);\n        let { success, steps } = hiddenNumber(newTarget, newHost, usedLastHere);\n        if (success && steps.indexOf(operations[r]) < 0) {\n          return { success, steps: [operations[r], ...steps] };\n        }\n      }\n    }\n  }\n\n  return { success: false, steps: [] };\n}\n","import hiddenNumber from \"./hiddenNumber\";\n\nconst tests = [\n  [\"2131\", \"39422\"],\n  [\"419\", \"10540\"],\n  [\"441\", \"10540\"],\n  [\"441\", \"10934\"],\n  [\"518\", \"10934\"],\n  [\"325\", \"6811\"],\n  [\"333\", \"10061\"],\n  [\"596\", \"5433\"],\n  [\"517\", \"11034\"],\n  [\"5\", \"12\"],\n  [\"52\", \"12\"],\n  [\"10\", \"100\"],\n  [\"100\", \"10\"],\n  [\"12\", \"5\"],\n  [\"400\", \"36677\"],\n  [\"218\", \"27764\"],\n  [\"596\", \"13778\"],\n  [\"321\", \"18441\"],\n  [\"321\", \"10628\"],\n  [\"321\", \"12247\"]\n];\n\ntests.forEach(([target, host]) => {\n  let result = hiddenNumber(target, host);\n  console.log({ host, target, ...result });\n});\n","import React, { useState } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./test.js\";\n\nimport \"./styles.css\";\n\nimport hiddenNumber from \"./hiddenNumber\";\n\nfunction App() {\n  const [state, setState] = useState({ target: \"\", host: \"\" });\n\n  const onChange = ({ target: { name, value } }) => {\n    setState({ ...state, [name]: value });\n  };\n\n  const result =\n    state.target &&\n    state.host &&\n    hiddenNumber(state.target, state.host, false, true);\n  return (\n    <div>\n      <h1>Find the target</h1>\n      <div>\n        <label>\n          <span>Target:</span>\n          <input\n            type=\"number\"\n            name=\"target\"\n            value={state.target}\n            onChange={onChange}\n            autoFocus={true}\n          />\n        </label>\n        <label>\n          <span>Host:</span>\n          <input\n            type=\"number\"\n            name=\"host\"\n            value={state.host}\n            onChange={onChange}\n          />\n        </label>\n        {result && (\n          <div className={`result ${result.success && \"SUCCESS\"}`}>\n            <span>{result.success ? \"SUCCESS\" : \"FAIL\"}</span>\n            {result.success && (\n              <ol>\n                {result.steps.map((step, index) => (\n                  <li key={index}>\n                    <pre>{step}</pre>\n                  </li>\n                ))}\n              </ol>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n//\n// console.clear();\n//\n// const tests = [\n//   // [\"2131\", \"39422\"],\n//   // [\"419\", \"10540\"],\n//   // [\"441\", \"10540\"],\n//   // [\"441\", \"10934\"],\n//   // [\"518\", \"10934\"],\n//   // [\"325\", \"6811\"],\n//   // [\"333\", \"10061\"],\n//   // [\"596\", \"5433\"],\n//   // [\"517\", \"11034\"],\n//   // [\"5\", \"12\"],\n//   // [\"52\", \"12\"],\n//   [\"10\", \"100\"],\n//   [\"100\", \"10\"]\n//   // [\"12\", \"5\"]\n// ];\n//\n// tests.forEach(([target, host]) => {\n//   let result = hiddenNumber(target, host);\n//   console.log({ host, target, result });\n// });\n"],"sourceRoot":""}